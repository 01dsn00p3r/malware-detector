#!/usr/bin/python3

import r2pipe, sys, argparse, string, binascii

def get_xor_from_key(key):
  return key[0]^key[1]^key[2]^key[3]

def detect_key(key): 
  looks_like = True
  for c in binascii.hexlify(key):
     if not chr(c) in ['a', 'b', 'c', 'd', 'e', 'f']:
      looks_like = False
  if looks_like:
    xor = get_xor_from_key(key)
    if bin(xor).count("1") in range(2,6):
      return xor
  return None 

def get_section_by_name(name):
  for section in sections:
    if section['name'] == name:
      if args.verbose:
        print('{} section found, size = {} address = {:#08x}'\
          .format(name, section['size'], section['vaddr']))
      return section
  return None

def extract_data_from_section(section, length = 0, offset = 0):
  if not length:
    length = section['size']
  if section and offset + length <= section['size']:
    return bytearray(r2p.cmdj('p8j {} @ section.{} + {}'.format(length, section['name'],  offset)))
  else:
    return None 

def find_keys(section):
  keys = []
  if section:
    data = extract_data_from_section(section)
    for i in range(0,len(data),4):
      if args.verbose:
        print('address: {:#08x} data: {:#08x}'\
          .format(section['vaddr'] + i, int.from_bytes(data[i:i+4], byteorder)))
      xor = detect_key(data[i:i+4])
      if xor:
        keys.append({'address': section['vaddr'] + i, 'data': data[i:i+4], 'xor': xor})
  return keys

def select_key(keys):
  if keys:
    if len(keys) == 1:
      return keys[0]
    else:
      for k in keys:
        print('Possible key found at address {:#08x} value: {:#08x}'\
            .format(k['address'], int.from_bytes(k['data'], byteorder)))   
        if input('Do you want to select this one ? (y/N)').lower() != "y":
          continue
        else:
          return k
  else:
    return None
 
def get_fcns_xrefs(address):
  xrefs = r2p.cmdj('axtj ' + str(address))
  if args.verbose:
    print(len(xrefs), 'key xrefs found:')
    for xref in xrefs:
      print('Address: {:#08x}, type: {}, function {}, instruction {}'\
        .format(xref['from'], xref['type'], xref['fcn_name'], xref['opcode']))
  return {  
      xref['fcn_name'] :
        [ 
          { attr:xref[attr] for attr in fcn if attr != 'fcn_name' }
            for fcn in xrefs if fcn['fcn_name'] == xref['fcn_name']
        ]
      for xref in xrefs
    }
  
def get_table_lock_unlock_xrefs(address):
  deobf_fcns = get_fcns_xrefs(address)
  if len(deobf_fcns) == 1:
    if args.verbose:
      print('One xref found. Probably unoptomized code - deobf() found, looking for callers...')
    for fnc, attr in deobf_fcns.items():
      deobf_fcns = get_fcns_xrefs(attr[0]['fcn_addr'])
  return deobf_fcns

def find_strings(data, xor = 0):
  found_str = ""
  for c in data:
    char = chr(c ^ xor)
    if c and char in set(string.printable):
      found_str += char
    elif len(found_str) >= 4:
      yield found_str
      found_str = ""
    else:
      found_str = ""

def detect_mirai():
  key = select_key(find_keys(get_section_by_name(".data"))) 
  if key:
    if args.verbose:
      print('Using key from address {:#08x} value: {:#08x}, xor: {:#02x}'\
            .format(key['address'], int.from_bytes(key['data'], byteorder) , key['xor'] & 0xff))   
  else:
    if args.verbose:
      print('No decryption key found, exiting...')
      return False
  lock_unlock_fcns = get_table_lock_unlock_xrefs(key['address'])   
  if not lock_unlock_fcns:
    if args.verbose:
      print('No obfuscation functions found')
    return False
  if args.verbose:
    print(len(lock_unlock_fcns), 'obfuscation function(s) found:')
    for fcn in lock_unlock_fcns:
      print(fcn)  
  data = extract_data_from_section(get_section_by_name(".rodata"))
  if args.verbose:
    print('xor decoded strings from .rodata:')
    for s in find_strings(data, key['xor']):
      print(s)    
  return True
  
parser = argparse.ArgumentParser(description='')
parser.add_argument('filename')
parser.add_argument('-v', '--verbose', action = 'store_true', help = 'run verbose')
args = parser.parse_args()

r2p=r2pipe.open(args.filename)  
r2p.cmd('aa;e anal.bb.maxsize=2048;aac;aae')  # analyze all symbols and calls
sections = r2p.cmdj('Sj')
variables = r2p.cmdj('ej')
# symbols = r2p.cmdj('aflj')

retval = {'undetected' : -1, 'Mirai' : 1}

byteorder = "big" if variables['cfg.bigendian'] else "little"

if args.verbose:
  print('CPU arch:', variables['asm.arch'])
  print('Using {} endian'.format(byteorder))
  
if detect_mirai():
  if args.verbose:
    print('Mirai positive')
  sys.exit(retval['Mirai'])
else:
  if args.verbose:
    print('No known malware detected')
  sys.exit(retval['undetected'])
  
